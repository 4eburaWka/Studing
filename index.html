<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Rubik's Cube</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <!-- <script src="three.module.js"></script>
    <script src="OrbitControls.js"></script> -->
    <script>
      import * as THREE from 'three.module.js';
      import {OrbitControls} from 'OrbitControls.js';

      // Инициализируем Three.js
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Инициализируем OrbitControls для вращения камеры вокруг сцены
      const controls = new THREE.OrbitControls(camera, renderer.domElement);

      // Инициализируем освещение сцены
      const light = new THREE.PointLight(0xffffff, 1, 100);
      light.position.set(0, 0, 5);
      scene.add(light);

      // Инициализируем материалы для цветов кубика
      const materials = [
        new THREE.MeshBasicMaterial({ color: 0x000000 }), // Не используется
        new THREE.MeshBasicMaterial({ color: 0xff0000 }), // Красный
        new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Зеленый
        new THREE.MeshBasicMaterial({ color: 0x0000ff }), // Синий
        new THREE.MeshBasicMaterial({ color: 0xffff00 }), // Желтый
        new THREE.MeshBasicMaterial({ color: 0xffa500 }), // Оранжевый
        new THREE.MeshBasicMaterial({ color: 0xffffff })  // Не используется
      ];

      // Инициализируем массив с позициями маленьких кубиков
      const positions = [
        [-1, -1, -1], [-1, -1, 0], [-1, -1, 1], [-1, 0, -1], [-1, 0, 0], [-1, 0, 1], [-1, 1, -1], [-1, 1, 0], [-1, 1, 1],
        [0, -1, -1], [0, -1, 0], [0, -1, 1], [0, 0, -1], [0, 0, 0], [0, 0, 1], [0, 1, -1], [0, 1, 0], [0, 1, 1],
        [1, -1, -1],
        [1, -1, 0], [1, -1, 1], [1, 0, -1], [1, 0, 0], [1, 0, 1], [1, 1, -1], [1, 1, 0], [1, 1, 1],
  ];

  // Инициализируем кубик Рубика
  const cubeSize = 2;
  const cube = new THREE.Object3D();
  const cubeGroup = new THREE.Group();

  for (let i = 0; i < 27; i++) {
    const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
    const material = materials[0];
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(
      positions[i][0] * cubeSize,
      positions[i][1] * cubeSize,
      positions[i][2] * cubeSize
    );
    cube.add(mesh);
  }

  cubeGroup.add(cube);
  scene.add(cubeGroup);

  // Инициализируем переменные для хранения состояния кубика
  const state = {
    "U": Array(9).fill(1),
    "D": Array(9).fill(4),
    "L": Array(9).fill(2),
    "R": Array(9).fill(3),
    "F": Array(9).fill(5),
    "B": Array(9).fill(6),
  };

  // Функция для поворота кубика
  const rotate = (face, clockwise) => {
    const faces = {
      "U": [0, 1, 2, 3, 4, 5, 6, 7, 8],
      "D": [18, 19, 20, 21, 22, 23, 24, 25, 26],
      "L": [0, 3, 6, 9, 12, 15, 18, 21, 24],
      "R": [2, 5, 8, 11, 14, 17, 20, 23, 26],
      "F": [6, 7, 8, 15, 16, 17, 24, 25, 26],
      "B": [0, 1, 2, 9, 10, 11, 18, 19, 20],
    };
    const oldState = state[face].slice();
    if (clockwise) {
      state[face][0] = oldState[6];
      state[face][1] = oldState[3];
      state[face][2] = oldState[0];
      state[face][3] = oldState[7];
      state[face][5] = oldState[1];
      state[face][6] = oldState[8];
      state[face][7] = oldState[5];
      state[face][8] = oldState[2];
    } else {
      state[face][0] = oldState[2];
      state[face][1] = oldState[5];
      state[face][2] = oldState[8];
      state[face][3] = oldState[1];
      state[face][5] = oldState[7];
      state[face][6] = oldState[0];
      state[face][7] = oldState[3];
state[face][8] = oldState[6];
}
const indices = faces[face];
const angle = clockwise ? -Math.PI / 2 : Math.PI / 2;
const matrix = new THREE.Matrix4().makeRotationY(angle);
for (let i = 0; i < indices.length; i++) {
const index = indices[i];
const currentMesh = cube.children[index];
currentMesh.applyMatrix4(matrix);
}
};
  // Обработчик нажатия клавиши
  const handleKeyDown = (event) => {
    const code = event.code;
    if (code === "KeyU") {
      rotate("U", true);
    } else if (code === "KeyD") {
      rotate("D", true);
    } else if (code === "KeyL") {
      rotate("L", true);
    } else if (code === "KeyR") {
      rotate("R", true);
    } else if (code === "KeyF") {
      rotate("F", true);
    } else if (code === "KeyB") {
      rotate("B", true);
    } else if (code === "KeyM") {
      rotate("R", true);
      rotate("L", false);
    } else if (code === "KeyE") {
      rotate("U", false);
      rotate("D", true);
    } else if (code === "KeyS") {
      rotate("F", true);
      rotate("B", false);
    }
  };

  document.addEventListener("keydown", handleKeyDown);

  // Рендерим сцену
  const animate = function () {
    requestAnimationFrame(animate);

    renderer.render(scene, camera);
  };

  animate();
  </script>
</body>
</html>	